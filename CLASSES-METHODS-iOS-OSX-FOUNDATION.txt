typedef NS_ENUM(NSInteger, NSComparisonResult) {NSOrderedAscending = -1L, NSOrderedSame, NSOrderedDescending};
    #define YES	(BOOL)1
	#define NO	(BOOL)0
	
	FOUNDATION_EXPORT NSString *NSStringFromSelector(SEL aSelector);
	FOUNDATION_EXPORT SEL NSSelectorFromString(NSString *aSelectorName);

	FOUNDATION_EXPORT NSString *NSStringFromClass(Class aClass);
	FOUNDATION_EXPORT Class NSClassFromString(NSString *aClassName);

	FOUNDATION_EXPORT NSString *NSStringFromProtocol(Protocol *proto) NS_AVAILABLE(10_5, 2_0);
	FOUNDATION_EXPORT Protocol *NSProtocolFromString(NSString *namestr) NS_AVAILABLE(10_5, 2_0);

	FOUNDATION_EXPORT void NSLogv(NSString *format, va_list args) NS_FORMAT_FUNCTION(1,0);
	FOUNDATION_EXPORT NSString * const NSSystemClockDidChangeNotification NS_AVAILABLE(10_6, 4_0);
	typedef double NSTimeInterval;
	#define NSTimeIntervalSince1970  978307200.0


NSData
			/****************	Read/Write Options	****************/

			typedef NS_OPTIONS(NSUInteger, NSDataReadingOptions) {
			    NSDataReadingMappedIfSafe =   1UL << 0,	// Hint to map the file in if possible and safe
			    NSDataReadingUncached = 1UL << 1,	// Hint to get the file not to be cached in the kernel
			    NSDataReadingMappedAlways NS_ENUM_AVAILABLE(10_7, 5_0) = 1UL << 3,	// Hint to map the file in if possible. This takes precedence over 
																						NSDataReadingMappedIfSafe if both are given.

			    // Options with old names for NSData reading methods. Please stop using these old names.
			    NSDataReadingMapped = NSDataReadingMappedIfSafe,	// Deprecated name for NSDataReadingMappedIfSafe
			    NSMappedRead = NSDataReadingMapped,			// Deprecated name for NSDataReadingMapped
			    NSUncachedRead = NSDataReadingUncached		// Deprecated name for NSDataReadingUncached
			};

			typedef NS_OPTIONS(NSUInteger, NSDataWritingOptions) {
			    NSDataWritingAtomic = 1UL << 0,	// Hint to use auxiliary file when saving; equivalent to atomically:YES
			    NSDataWritingWithoutOverwriting NS_ENUM_AVAILABLE(10_8, 6_0) = 1UL << 1, // Hint to  prevent overwriting an existing file. Cannot be combined with 
																							NSDataWritingAtomic.

			    NSDataWritingFileProtectionNone NS_ENUM_AVAILABLE_IOS(4_0)                                  = 0x10000000,
			    NSDataWritingFileProtectionComplete NS_ENUM_AVAILABLE_IOS(4_0)                              = 0x20000000,
			    NSDataWritingFileProtectionCompleteUnlessOpen NS_ENUM_AVAILABLE_IOS(5_0)                    = 0x30000000,
			    NSDataWritingFileProtectionCompleteUntilFirstUserAuthentication NS_ENUM_AVAILABLE_IOS(5_0)  = 0x40000000,
			    NSDataWritingFileProtectionMask NS_ENUM_AVAILABLE_IOS(4_0)                                  = 0xf0000000,

			    // Options with old names for NSData writing methods. Please stop using these old names.
			    NSAtomicWrite = NSDataWritingAtomic	    // Deprecated name for NSDataWritingAtomic
			};


			/****************	Data Search Options	****************/

			typedef NS_OPTIONS(NSUInteger, NSDataSearchOptions) {
			    NSDataSearchBackwards = 1UL << 0,
			    NSDataSearchAnchored = 1UL << 1
			} NS_ENUM_AVAILABLE(10_6, 4_0);


	@property (readonly) NSUInteger length;
	@property (readonly, copy) NSString *description;
	
	+ (instancetype)data;
	+ (instancetype)dataWithBytes:(const void *)bytes length:(NSUInteger)length;
	+ (instancetype)dataWithContentsOfFile:(NSString *)path options:(NSDataReadingOptions)readOptionsMask error:(NSError **)errorPtr;
	+ (instancetype)dataWithContentsOfURL:(NSURL *)url options:(NSDataReadingOptions)readOptionsMask error:(NSError **)errorPtr;
	+ (instancetype)dataWithContentsOfFile:(NSString *)path;
	+ (instancetype)dataWithContentsOfURL:(NSURL *)url;
	- (instancetype)initWithBytes:(const void *)bytes length:(NSUInteger)length;
	- (instancetype)initWithContentsOfFile:(NSString *)path options:(NSDataReadingOptions)readOptionsMask error:(NSError **)errorPtr;
	- (instancetype)initWithContentsOfURL:(NSURL *)url options:(NSDataReadingOptions)readOptionsMask error:(NSError **)errorPtr;
	- (instancetype)initWithContentsOfFile:(NSString *)path;
	- (instancetype)initWithContentsOfURL:(NSURL *)url;
	- (instancetype)initWithData:(NSData *)data;
	+ (instancetype)dataWithData:(NSData *)data;
	
	- (void)getBytes:(void *)buffer length:(NSUInteger)length;
	- (void)getBytes:(void *)buffer range:(NSRange)range;
	- (BOOL)isEqualToData:(NSData *)other;
	- (NSData *)subdataWithRange:(NSRange)range;

	- (BOOL)writeToFile:(NSString *)path atomically:(BOOL)useAuxiliaryFile;
	- (BOOL)writeToFile:(NSString *)path options:(NSDataWritingOptions)writeOptionsMask error:(NSError **)errorPtr;

	- (BOOL)writeToURL:(NSURL *)url atomically:(BOOL)atomically; // the atomically flag is ignored if the url is not of a type the supports atomic writes
	- (BOOL)writeToURL:(NSURL *)url options:(NSDataWritingOptions)writeOptionsMask error:(NSError **)errorPtr;

	- (NSRange)rangeOfData:(NSData *)dataToFind options:(NSDataSearchOptions)mask range:(NSRange)searchRange NS_AVAILABLE(10_6, 4_0);

	NSMutableData	
	- (void)appendBytes:(const void *)bytes length:(NSUInteger)length;
	- (void)appendData:(NSData *)other;
	- (void)increaseLengthBy:(NSUInteger)extraLength;
	- (void)replaceBytesInRange:(NSRange)range withBytes:(const void *)bytes;
	- (void)resetBytesInRange:(NSRange)range;
	- (void)setData:(NSData *)data;
	- (void)replaceBytesInRange:(NSRange)range withBytes:(const void *)replacementBytes length:(NSUInteger)replacementLength;

	+ (instancetype)dataWithCapacity:(NSUInteger)aNumItems;
	+ (instancetype)dataWithLength:(NSUInteger)length;
	- (instancetype)initWithCapacity:(NSUInteger)capacity;
	- (instancetype)initWithLength:(NSUInteger)length;
	
NSRange => Not a class but a structure
				typedef struct _NSRange {
				    NSUInteger location;
				    NSUInteger length;
				} NSRange;
			NS_INLINE NSRange NSMakeRange(NSUInteger loc, NSUInteger len) {
			    NSRange r;
			    r.location = loc;
			    r.length = len;
			    return r;
			}

			NS_INLINE NSUInteger NSMaxRange(NSRange range) {
			    return (range.location + range.length);
			}

			NS_INLINE BOOL NSLocationInRange(NSUInteger loc, NSRange range) {
			    return (!(loc < range.location) && (loc - range.location) < range.length) ? YES : NO;
			}

			NS_INLINE BOOL NSEqualRanges(NSRange range1, NSRange range2) {
			    return (range1.location == range2.location && range1.length == range2.length);
			}
	

NSCharacterSet.h
	+ (NSCharacterSet *)controlCharacterSet;
	+ (NSCharacterSet *)whitespaceCharacterSet;
	+ (NSCharacterSet *)whitespaceAndNewlineCharacterSet;
	+ (NSCharacterSet *)decimalDigitCharacterSet;
	+ (NSCharacterSet *)letterCharacterSet;
	+ (NSCharacterSet *)lowercaseLetterCharacterSet;
	+ (NSCharacterSet *)uppercaseLetterCharacterSet;
	+ (NSCharacterSet *)alphanumericCharacterSet;
	+ (NSCharacterSet *)punctuationCharacterSet;
	+ (NSCharacterSet *)capitalizedLetterCharacterSet;
	+ (NSCharacterSet *)newlineCharacterSet NS_AVAILABLE(10_5, 2_0);

	+ (NSCharacterSet *)characterSetWithRange:(NSRange)aRange;
	+ (NSCharacterSet *)characterSetWithCharactersInString:(NSString *)aString;

	- (BOOL)characterIsMember:(unichar)aCharacter;
	- (BOOL)isSupersetOfSet:(NSCharacterSet *)theOtherSet;
	
	NSMutableCharacterSet	
		- (void)addCharactersInRange:(NSRange)aRange;
		- (void)removeCharactersInRange:(NSRange)aRange;
		- (void)addCharactersInString:(NSString *)aString;
		- (void)removeCharactersInString:(NSString *)aString;
		- (void)formUnionWithCharacterSet:(NSCharacterSet *)otherSet;
		- (void)formIntersectionWithCharacterSet:(NSCharacterSet *)otherSet;
		
NSDate
	- (instancetype)init NS_DESIGNATED_INITIALIZER;
	- (instancetype)initWithTimeIntervalSinceReferenceDate:(NSTimeInterval)ti NS_DESIGNATED_INITIALIZER;
	- (NSTimeInterval)timeIntervalSinceDate:(NSDate *)anotherDate;
	- (id)addTimeInterval:(NSTimeInterval)seconds NS_DEPRECATED(10_0, 10_6, 2_0, 4_0);
	- (instancetype)dateByAddingTimeInterval:(NSTimeInterval)ti NS_AVAILABLE(10_6, 2_0);
	- (NSDate *)earlierDate:(NSDate *)anotherDate;
	- (NSDate *)laterDate:(NSDate *)anotherDate;
	- (NSComparisonResult)compare:(NSDate *)other;
	- (BOOL)isEqualToDate:(NSDate *)otherDate;

	+ (NSTimeInterval)timeIntervalSinceReferenceDate;
	
	+ (instancetype)date;
	+ (instancetype)dateWithTimeIntervalSinceNow:(NSTimeInterval)secs;
	+ (instancetype)dateWithTimeIntervalSinceReferenceDate:(NSTimeInterval)ti;
	+ (instancetype)dateWithTimeIntervalSince1970:(NSTimeInterval)secs;
	+ (instancetype)dateWithTimeInterval:(NSTimeInterval)secsToBeAdded sinceDate:(NSDate *)date;

	+ (id /* NSDate * */)distantFuture;
	+ (id /* NSDate * */)distantPast;

	- (instancetype)initWithTimeIntervalSinceNow:(NSTimeInterval)secs;
	- (instancetype)initWithTimeIntervalSince1970:(NSTimeInterval)secs;
	- (instancetype)initWithTimeInterval:(NSTimeInterval)secsToBeAdded sinceDate:(NSDate *)date;
	
	@property (readonly) NSTimeInterval timeIntervalSinceNow;
	@property (readonly) NSTimeInterval timeIntervalSince1970;
		
	NSDateFormatter
					typedef NS_ENUM(NSUInteger, NSDateFormatterStyle) {    // date and time format styles
					    NSDateFormatterNoStyle = kCFDateFormatterNoStyle,
					    NSDateFormatterShortStyle = kCFDateFormatterShortStyle,
					    NSDateFormatterMediumStyle = kCFDateFormatterMediumStyle,
					    NSDateFormatterLongStyle = kCFDateFormatterLongStyle,
					    NSDateFormatterFullStyle = kCFDateFormatterFullStyle
					};
	
				@property (copy) NSString *dateFormat;
				@property NSDateFormatterStyle dateStyle;
				@property NSDateFormatterStyle timeStyle;
				@property (copy) NSLocale *locale;
				@property BOOL generatesCalendarDates;
				@property NSDateFormatterBehavior formatterBehavior;
				@property (copy) NSTimeZone *timeZone;
				@property (copy) NSCalendar *calendar;
				@property (getter=isLenient) BOOL lenient;
				@property (copy) NSDate *twoDigitStartDate;
				@property (copy) NSDate *defaultDate;
				@property (copy) NSArray *eraSymbols;
				@property (copy) NSArray *monthSymbols;
				@property (copy) NSArray *shortMonthSymbols;
				@property (copy) NSArray *weekdaySymbols;
				@property (copy) NSArray *shortWeekdaySymbols;
				@property (copy) NSString *AMSymbol;
				@property (copy) NSString *PMSymbol;
				@property (copy) NSArray *longEraSymbols NS_AVAILABLE(10_5, 2_0);
				@property (copy) NSArray *veryShortMonthSymbols NS_AVAILABLE(10_5, 2_0);
				@property (copy) NSArray *standaloneMonthSymbols NS_AVAILABLE(10_5, 2_0);
				@property (copy) NSArray *shortStandaloneMonthSymbols NS_AVAILABLE(10_5, 2_0);
				@property (copy) NSArray *veryShortStandaloneMonthSymbols NS_AVAILABLE(10_5, 2_0);
				@property (copy) NSArray *veryShortWeekdaySymbols NS_AVAILABLE(10_5, 2_0);
				@property (copy) NSArray *standaloneWeekdaySymbols NS_AVAILABLE(10_5, 2_0);
				@property (copy) NSArray *shortStandaloneWeekdaySymbols NS_AVAILABLE(10_5, 2_0);
				@property (copy) NSArray *veryShortStandaloneWeekdaySymbols NS_AVAILABLE(10_5, 2_0);
				@property (copy) NSArray *quarterSymbols NS_AVAILABLE(10_5, 2_0);
				@property (copy) NSArray *shortQuarterSymbols NS_AVAILABLE(10_5, 2_0);
				@property (copy) NSArray *standaloneQuarterSymbols NS_AVAILABLE(10_5, 2_0);
				@property (copy) NSArray *shortStandaloneQuarterSymbols NS_AVAILABLE(10_5, 2_0);
				@property (copy) NSDate *gregorianStartDate NS_AVAILABLE(10_5, 2_0);
				@property BOOL doesRelativeDateFormatting NS_AVAILABLE(10_6, 4_0);
		
	- (NSString *)stringFromDate:(NSDate *)date;
	- (NSDate *)dateFromString:(NSString *)string;
				
NSTimeZone
				@property (readonly) NSInteger secondsFromGMT;
				@property (readonly, copy) NSString *abbreviation;
				@property (readonly, getter=isDaylightSavingTime) BOOL daylightSavingTime;
				@property (readonly) NSTimeInterval daylightSavingTimeOffset NS_AVAILABLE(10_5, 2_0); // for current instant
				@property (readonly, copy) NSDate *nextDaylightSavingTimeTransition NS_AVAILABLE(10_5, 2_0); // after current instant

				typedef NS_ENUM(NSInteger, NSTimeZoneNameStyle) {
					NSTimeZoneNameStyleStandard,		// Central Standard Time
					NSTimeZoneNameStyleShortStandard,	// CST
					NSTimeZoneNameStyleDaylightSaving,	// Central Daylight Time
					NSTimeZoneNameStyleShortDaylightSaving,	// CDT
					NSTimeZoneNameStyleGeneric,		// Central Time
					NSTimeZoneNameStyleShortGeneric		// CT
				};

	- (NSInteger)secondsFromGMTForDate:(NSDate *)aDate;
	- (NSString *)abbreviationForDate:(NSDate *)aDate;
	- (BOOL)isDaylightSavingTimeForDate:(NSDate *)aDate;
	- (NSTimeInterval)daylightSavingTimeOffsetForDate:(NSDate *)aDate NS_AVAILABLE(10_5, 2_0);
	- (NSDate *)nextDaylightSavingTimeTransitionAfterDate:(NSDate *)aDate NS_AVAILABLE(10_5, 2_0);

	- (BOOL)isEqualToTimeZone:(NSTimeZone *)aTimeZone;

	+ (NSTimeZone *)systemTimeZone;
	+ (void)resetSystemTimeZone;

	+ (NSTimeZone *)defaultTimeZone;
	+ (void)setDefaultTimeZone:(NSTimeZone *)aTimeZone;

	+ (NSTimeZone *)localTimeZone;

	+ (NSArray *)knownTimeZoneNames;

	+ (NSDictionary *)abbreviationDictionary;
	+ (void)setAbbreviationDictionary:(NSDictionary *)dict NS_AVAILABLE(10_6, 4_0);

	+ (NSString *)timeZoneDataVersion NS_AVAILABLE(10_6, 4_0);

	+ (instancetype)timeZoneWithName:(NSString *)tzName;
	+ (instancetype)timeZoneWithName:(NSString *)tzName data:(NSData *)aData;

	- (instancetype)initWithName:(NSString *)tzName;
	- (instancetype)initWithName:(NSString *)tzName data:(NSData *)aData;

	// Time zones created with this never have daylight savings and the
	// offset is constant no matter the date; the name and abbreviation
	// do NOT follow the POSIX convention (of minutes-west).
	+ (instancetype)timeZoneForSecondsFromGMT:(NSInteger)seconds;

	+ (instancetype)timeZoneWithAbbreviation:(NSString *)abbreviation;
	

NSDateIntervalFormatter
				typedef NS_ENUM(NSUInteger, NSDateIntervalFormatterStyle) {
				    NSDateIntervalFormatterNoStyle = 0,
				    NSDateIntervalFormatterShortStyle = 1,
				    NSDateIntervalFormatterMediumStyle = 2,
				    NSDateIntervalFormatterLongStyle = 3,
				    NSDateIntervalFormatterFullStyle = 4
				} NS_ENUM_AVAILABLE(10_10, 8_0);
	
				@property (copy) NSLocale   *locale;                // default is [NSLocale currentLocale]
				@property (copy) NSCalendar *calendar;              // default is the calendar of the locale
				@property (copy) NSTimeZone *timeZone;              // default is [NSTimeZone defaultTimeZone]
				@property (copy) NSString   *dateTemplate;          // default is an empty string
				@property NSDateIntervalFormatterStyle dateStyle;   // default is NSDateIntervalFormatterNoStyle
				@property NSDateIntervalFormatterStyle timeStyle;   // default is NSDateIntervalFormatterNoStyle

	- (NSString *)stringFromDate:(NSDate *)fromDate toDate:(NSDate *)toDate;


		
NSValue
	- (instancetype)initWithBytes:(const void *)value objCType:(const char *)type NS_DESIGNATED_INITIALIZER;
	- (instancetype)initWithCoder:(NSCoder *)aDecoder NS_DESIGNATED_INITIALIZER;
	+ (NSValue *)valueWithBytes:(const void *)value objCType:(const char *)type;
	+ (NSValue *)value:(const void *)value withObjCType:(const char *)type;
	
NSNumber
	- (NSNumber *)initWithChar:(char)value NS_DESIGNATED_INITIALIZER;
	- (NSNumber *)initWithUnsignedChar:(unsigned char)value NS_DESIGNATED_INITIALIZER;
	- (NSNumber *)initWithShort:(short)value NS_DESIGNATED_INITIALIZER;
	- (NSNumber *)initWithUnsignedShort:(unsigned short)value NS_DESIGNATED_INITIALIZER;
	- (NSNumber *)initWithInt:(int)value NS_DESIGNATED_INITIALIZER;
	- (NSNumber *)initWithUnsignedInt:(unsigned int)value NS_DESIGNATED_INITIALIZER;
	- (NSNumber *)initWithLong:(long)value NS_DESIGNATED_INITIALIZER;
	- (NSNumber *)initWithUnsignedLong:(unsigned long)value NS_DESIGNATED_INITIALIZER;
	- (NSNumber *)initWithLongLong:(long long)value NS_DESIGNATED_INITIALIZER;
	- (NSNumber *)initWithUnsignedLongLong:(unsigned long long)value NS_DESIGNATED_INITIALIZER;
	- (NSNumber *)initWithFloat:(float)value NS_DESIGNATED_INITIALIZER;
	- (NSNumber *)initWithDouble:(double)value NS_DESIGNATED_INITIALIZER;
	- (NSNumber *)initWithBool:(BOOL)value NS_DESIGNATED_INITIALIZER;
	- (NSNumber *)initWithInteger:(NSInteger)value NS_AVAILABLE(10_5, 2_0) NS_DESIGNATED_INITIALIZER;
	- (NSNumber *)initWithUnsignedInteger:(NSUInteger)value NS_AVAILABLE(10_5, 2_0) NS_DESIGNATED_INITIALIZER;

	@property (readonly, copy) NSString *stringValue;
	
	- (NSComparisonResult)compare:(NSNumber *)otherNumber;	

	- (BOOL)isEqualToNumber:(NSNumber *)number;
	
	+ (NSNumber *)numberWithChar:(char)value;
	+ (NSNumber *)numberWithUnsignedChar:(unsigned char)value;
	+ (NSNumber *)numberWithShort:(short)value;
	+ (NSNumber *)numberWithUnsignedShort:(unsigned short)value;
	+ (NSNumber *)numberWithInt:(int)value;
	+ (NSNumber *)numberWithUnsignedInt:(unsigned int)value;
	+ (NSNumber *)numberWithLong:(long)value;
	+ (NSNumber *)numberWithUnsignedLong:(unsigned long)value;
	+ (NSNumber *)numberWithLongLong:(long long)value;
	+ (NSNumber *)numberWithUnsignedLongLong:(unsigned long long)value;
	+ (NSNumber *)numberWithFloat:(float)value;
	+ (NSNumber *)numberWithDouble:(double)value;
	+ (NSNumber *)numberWithBool:(BOOL)value;
	+ (NSNumber *)numberWithInteger:(NSInteger)value NS_AVAILABLE(10_5, 2_0);
	+ (NSNumber *)numberWithUnsignedInteger:(NSUInteger)value NS_AVAILABLE(10_5, 2_0);
		
NSException

			@property (readonly, copy) NSString *name;
			@property (readonly, copy) NSString *reason;
			@property (readonly, copy) NSDictionary *userInfo;
			
	+ (NSException *)exceptionWithName:(NSString *)name reason:(NSString *)reason userInfo:(NSDictionary *)userInfo;
	- (instancetype)initWithName:(NSString *)aName reason:(NSString *)aReason userInfo:(NSDictionary *)aUserInfo NS_DESIGNATED_INITIALIZER;
	
	+ (void)raise:(NSString *)name format:(NSString *)format, ... NS_FORMAT_FUNCTION(2,3);
	+ (void)raise:(NSString *)name format:(NSString *)format arguments:(va_list)argList NS_FORMAT_FUNCTION(2,0);
	
	
NSJSonSerialization

					/* 	Returns YES if the given object can be converted to JSON data, NO otherwise. The object must have the following properties:
					    	- Top level object is an NSArray or NSDictionary
					    	- All objects are NSString, NSNumber, NSArray, NSDictionary, or NSNull
					    	- All dictionary keys are NSStrings
					    	- NSNumbers are not NaN or infinity
					 	Other rules may apply. Calling this method or attempting a conversion are the definitive ways to tell if a given object can be converted to 
						JSON data.
					*/
		
		+ (BOOL)isValidJSONObject:(id)obj;

					/* Generate JSON data from a Foundation object. If the object will not produce valid JSON then an exception will be thrown. Setting the
					 	NSJSONWritingPrettyPrinted option will generate JSON with whitespace designed to make the output more readable. If that option is not set, 
						the most compact possible JSON will be generated. If an error occurs, the error parameter will be set and the return value will be nil. The 
						resulting data is a encoded in	UTF-8.
					 */
		+ (NSData *)dataWithJSONObject:(id)obj options:(NSJSONWritingOptions)opt error:(NSError **)error;

					/* Create a Foundation object from JSON data. Set the NSJSONReadingAllowFragments option if the parser should allow top-level objects that are 
						not an NSArray or NSDictionary. Setting the NSJSONReadingMutableContainers option will make the parser generate mutable NSArrays and 
						NSDictionaries. Setting the NSJSONReadingMutableLeaves option will make the parser generate mutable NSString objects. If an error occurs 
						during the parse, then the error parameter will be set and the result will be nil. The data must be in one of the 5 supported encodings 
						listed in the JSON specification: UTF-8, UTF-16LE, UTF-16BE, UTF-32LE, UTF-32BE. The data may or may not have a BOM. The most efficient 
						encoding to use for parsing is UTF-8, so if you have a choice in encoding the data passed to this method, use UTF-8.
					 */
		+ (id)JSONObjectWithData:(NSData *)data options:(NSJSONReadingOptions)opt error:(NSError **)error;

					/* Write JSON data into a stream. The stream should be opened and configured. The return value is the number of bytes written to the stream, or 0 
						on error. All other behavior of this method is the same as the dataWithJSONObject:options:error: method.
					 */
		+ (NSInteger)writeJSONObject:(id)obj toStream:(NSOutputStream *)stream options:(NSJSONWritingOptions)opt error:(NSError **)error;

					/* Create a JSON object from JSON data stream. The stream should be opened and configured. All other behavior of this method is the same as the 
						JSONObjectWithData:options:error: method.
					 */
		+ (id)JSONObjectWithStream:(NSInputStream *)stream options:(NSJSONReadingOptions)opt error:(NSError **)error;


NSNotification

			@property (readonly, copy) NSString *name;
			@property (readonly, retain) id object;
			@property (readonly, copy) NSDictionary *userInfo;

			- (instancetype)initWithName:(NSString *)name object:(id)object userInfo:(NSDictionary *)userInfo
			+ (instancetype)notificationWithName:(NSString *)aName object:(id)anObject;
			+ (instancetype)notificationWithName:(NSString *)aName object:(id)anObject userInfo:(NSDictionary *)aUserInfo;
			
			
NSNotificationCenter
		+ (NSNotificationCenter *)defaultCenter;

		- (void)addObserver:(id)observer selector:(SEL)aSelector name:(NSString *)aName object:(id)anObject;

		- (void)postNotification:(NSNotification *)notification;
		- (void)postNotificationName:(NSString *)aName object:(id)anObject;
		- (void)postNotificationName:(NSString *)aName object:(id)anObject userInfo:(NSDictionary *)aUserInfo;

		- (void)removeObserver:(id)observer;
		- (void)removeObserver:(id)observer name:(NSString *)aName object:(id)anObject;

		- (id <NSObject>)addObserverForName:(NSString *)name object:(id)obj queue:(NSOperationQueue *)queue usingBlock:(void (^)(NSNotification *note))block 
		NS_AVAILABLE(10_6, 4_0);			
		
NSNotificationQueue
					typedef NS_ENUM(NSUInteger, NSPostingStyle) {
					    NSPostWhenIdle = 1,
					    NSPostASAP = 2,
					    NSPostNow = 3
					};

					typedef NS_ENUM(NSUInteger, NSNotificationCoalescing) {
					    NSNotificationNoCoalescing = 0,
					    NSNotificationCoalescingOnName = 1,
					    NSNotificationCoalescingOnSender = 2
					};

		+ (NSNotificationQueue *)defaultQueue;
		- (instancetype)initWithNotificationCenter:(NSNotificationCenter *)notificationCenter 
		- (void)enqueueNotification:(NSNotification *)notification postingStyle:(NSPostingStyle)postingStyle;
		- (void)enqueueNotification:(NSNotification *)notification postingStyle:(NSPostingStyle)postingStyle coalesceMask:(NSUInteger)coalesceMask forModes:(NSArray 
		*)modes;

		- (void)dequeueNotificationsMatching:(NSNotification *)notification coalesceMask:(NSUInteger)coalesceMask;
		
NSPathUtilities
		+ (NSString *)pathWithComponents:(NSArray *)components;
		@property (readonly, copy) NSArray *pathComponents;

		@property (getter=isAbsolutePath, readonly) BOOL absolutePath;

		@property (readonly, copy) NSString *lastPathComponent;
		@property (readonly, copy) NSString *stringByDeletingLastPathComponent;
		- (NSString *)stringByAppendingPathComponent:(NSString *)str;

		@property (readonly, copy) NSString *pathExtension;
		@property (readonly, copy) NSString *stringByDeletingPathExtension;
		- (NSString *)stringByAppendingPathExtension:(NSString *)str;

		@property (readonly, copy) NSString *stringByAbbreviatingWithTildeInPath;
		@property (readonly, copy) NSString *stringByExpandingTildeInPath;

		@property (readonly, copy) NSString *stringByStandardizingPath;

		@property (readonly, copy) NSString *stringByResolvingSymlinksInPath;

		- (NSArray *)stringsByAppendingPaths:(NSArray *)paths;

				typedef NS_ENUM(NSUInteger, NSSearchPathDirectory) {
				    NSApplicationDirectory = 1,             // supported applications (Applications)
				    NSDemoApplicationDirectory,             // unsupported applications, demonstration versions (Demos)
				    NSDeveloperApplicationDirectory,        // developer applications (Developer/Applications). DEPRECATED - there is no one single Developer 
																directory.
				    NSAdminApplicationDirectory,            // system and network administration applications (Administration)
				    NSLibraryDirectory,                     // various documentation, support, and configuration files, resources (Library)
				    NSDeveloperDirectory,                   // developer resources (Developer) DEPRECATED - there is no one single Developer directory.
				    NSUserDirectory,                        // user home directories (Users)
				    NSDocumentationDirectory,               // documentation (Documentation)
				    NSDocumentDirectory,                    // documents (Documents)
				    NSCoreServiceDirectory,                 // location of CoreServices directory (System/Library/CoreServices)
				    NSAutosavedInformationDirectory NS_ENUM_AVAILABLE(10_6, 4_0) = 11,   // location of autosaved documents (Documents/Autosaved)
				    NSDesktopDirectory = 12,                // location of user's desktop
				    NSCachesDirectory = 13,                 // location of discardable cache files (Library/Caches)
				    NSApplicationSupportDirectory = 14,     // location of application support files (plug-ins, etc) (Library/Application Support)
				    NSDownloadsDirectory NS_ENUM_AVAILABLE(10_5, 2_0) = 15,              // location of the user's "Downloads" directory
				    NSInputMethodsDirectory NS_ENUM_AVAILABLE(10_6, 4_0) = 16,           // input methods (Library/Input Methods)
				    NSMoviesDirectory NS_ENUM_AVAILABLE(10_6, 4_0) = 17,                 // location of user's Movies directory (~/Movies)
				    NSMusicDirectory NS_ENUM_AVAILABLE(10_6, 4_0) = 18,                  // location of user's Music directory (~/Music)
				    NSPicturesDirectory NS_ENUM_AVAILABLE(10_6, 4_0) = 19,               // location of user's Pictures directory (~/Pictures)
				    NSPrinterDescriptionDirectory NS_ENUM_AVAILABLE(10_6, 4_0) = 20,     // location of system's PPDs directory (Library/Printers/PPDs)
				    NSSharedPublicDirectory NS_ENUM_AVAILABLE(10_6, 4_0) = 21,           // location of user's Public sharing directory (~/Public)
				    NSPreferencePanesDirectory NS_ENUM_AVAILABLE(10_6, 4_0) = 22,        // location of the PreferencePanes directory for use with System Preferences 
																							(Library/PreferencePanes)
				    NSApplicationScriptsDirectory NS_ENUM_AVAILABLE(10_8, NA) = 23,      // location of the user scripts folder for the calling application 
																							(~/Library/Application Scripts/code-signing-id)
				    NSItemReplacementDirectory NS_ENUM_AVAILABLE(10_6, 4_0) = 99,	    // For use with NSFileManager's 
																							URLForDirectory:inDomain:appropriateForURL:create:error:
				    NSAllApplicationsDirectory = 100,       // all directories where applications can occur
				    NSAllLibrariesDirectory = 101,          // all directories where resources can occur
				    NSTrashDirectory NS_ENUM_AVAILABLE(10_8, NA) = 102                   // location of Trash directory

				};

				typedef NS_OPTIONS(NSUInteger, NSSearchPathDomainMask) {
				    NSUserDomainMask = 1,       // user's home directory --- place to install user's personal items (~)
				    NSLocalDomainMask = 2,      // local to the current machine --- place to install items available to everyone on this machine (/Library)
				    NSNetworkDomainMask = 4,    // publically available location in the local area network --- place to install items available on the network 
													(/Network)
				    NSSystemDomainMask = 8,     // provided by Apple, unmodifiable (/System)
				    NSAllDomainsMask = 0x0ffff  // all domains: all of the above and future items
				};

				FOUNDATION_EXPORT NSArray *NSSearchPathForDirectoriesInDomains(NSSearchPathDirectory directory, NSSearchPathDomainMask domainMask, BOOL expandTilde);


NSProcessInfo
			enum {	/* Constants returned by -operatingSystem */
			    NSWindowsNTOperatingSystem = 1,
			    NSWindows95OperatingSystem,
			    NSSolarisOperatingSystem,
			    NSHPUXOperatingSystem,
			    NSMACHOperatingSystem,
			    NSSunOSOperatingSystem,
			    NSOSF1OperatingSystem
			} NS_ENUM_DEPRECATED(10_0, 10_10, 2_0, 8_0);

			typedef struct {
			    NSInteger majorVersion;
			    NSInteger minorVersion;
			    NSInteger patchVersion;
			} NSOperatingSystemVersion;

			@class NSArray, NSString, NSDictionary;

			@interface NSProcessInfo : NSObject {
			@private
			    NSDictionary	*environment;
			    NSArray		*arguments;
			    NSString		*hostName;
			    NSString		*name;
			    NSInteger		automaticTerminationOptOutCounter;
			}

			+ (NSProcessInfo *)processInfo;

			@property (readonly, copy) NSDictionary *environment;
			@property (readonly, copy) NSArray *arguments;
			@property (readonly, copy) NSString *hostName;
			@property (copy) NSString *processName;
			@property (readonly) int processIdentifier;

			@property (readonly, copy) NSString *globallyUniqueString;

			- (NSUInteger)operatingSystem NS_DEPRECATED(10_0, 10_10, 2_0, 8_0, "-operatingSystem always returns NSMACHOperatingSystem, use -operatingSystemVersion or 
																				-isOperatingSystemAtLeastVersion: instead");
			- (NSString *)operatingSystemName NS_DEPRECATED(10_0, 10_10, 2_0, 8_0, "-operatingSystemName always returns NSMACHOperatingSystem, use 
																					-operatingSystemVersionString instead");

				/* Human readable, localized; appropriate for displaying to user or using in bug emails and such; NOT appropriate for parsing */
			@property (readonly, copy) NSString *operatingSystemVersionString;

			@property (readonly) NSOperatingSystemVersion operatingSystemVersion NS_AVAILABLE(10_10, 8_0);

			@property (readonly) NSUInteger processorCount NS_AVAILABLE(10_5, 2_0);
			@property (readonly) NSUInteger activeProcessorCount NS_AVAILABLE(10_5, 2_0);
			@property (readonly) unsigned long long physicalMemory NS_AVAILABLE(10_5, 2_0);

			- (BOOL) isOperatingSystemAtLeastVersion:(NSOperatingSystemVersion)version NS_AVAILABLE(10_10, 8_0);
			@property (readonly) NSTimeInterval systemUptime NS_AVAILABLE(10_6, 4_0);

			/* Disable or reenable the ability to be quickly killed. The default implementations of these methods increment or decrement, respectively, a counter 
			whose value is 1 when the process is first created. When the counter's value is 0 the application is considered to be safely killable and may be killed 
			by the operating system without any notification or event being sent to the process first. If an application's Info.plist has an 
			NSSupportsSuddenTermination entry whose value is true then NSApplication invokes -enableSuddenTermination automatically during application launch, which 
			typically renders the process killable right away. You can also manually invoke -enableSuddenTermination right away in, for example, agents or daemons 
			that don't depend on AppKit. After that, you can invoke these methods whenever the process has work it must do before it terminates. For example:
			
			 - NSUserDefaults uses these to prevent process killing between the time at which a default has been set and the time at which the preferences file 
			 	including that default has been written to disk.
			 - NSDocument uses these to prevent process killing between the time at which the user has made a change to a document and the time at which the user's 
				 change has been written to disk.
			 - You can use these whenever your application defers work that must be done before the application terminates. If for example your application ever 
			 	defers writing something to disk, and it has an NSSupportsSuddenTermination entry in its Info.plist so as not to contribute to user-visible delays at 
				logout or shutdown time, it must invoke -disableSuddenTermination when the writing is first deferred and -enableSuddenTermination after the writing 				is actually done.
			 */
			 
			- (void)disableSuddenTermination NS_AVAILABLE(10_6, NA);
			- (void)enableSuddenTermination NS_AVAILABLE(10_6, NA);

			/*
			 * Increment or decrement the counter tracking the number of automatic quit opt-out requests. When this counter is greater than zero, the app will be 
			 	considered 'active' and ineligible for automatic termination.
			 * An example of using this would be disabling autoquitting when the user of an instant messaging application signs on, due to it requiring a background 
			 	connection to be maintained even if the app is otherwise inactive.
			 * Each pair of calls should have a matching "reason" argument, which can be used to easily track why an application is or is not automatically 
			 	terminable.
			 * A given reason can be used more than once at the same time (for example: two files are transferring over the network, each one disables automatic 
			 	termination with the reason @"file transfer in progress")
			 */
			- (void)disableAutomaticTermination:(NSString *)reason NS_AVAILABLE(10_7, NA);
			- (void)enableAutomaticTermination:(NSString *)reason NS_AVAILABLE(10_7, NA);

			/*
			 * Marks the calling app as supporting automatic termination. Without calling this or setting the equivalent Info.plist key 
			 	(NSSupportsAutomaticTermination), the above methods (disableAutomaticTermination:/enableAutomaticTermination:) have no effect,
			 * although the counter tracking automatic termination opt-outs is still kept up to date to ensure correctness if this is called later. Currently, 
			 	passing NO has no effect.
			 * This should be called during -applicationDidFinishLaunching or earlier.
			 */
			 
			@property BOOL automaticTerminationSupportEnabled NS_AVAILABLE(10_7, NA);

			@end

			/*
			 The system has heuristics to improve battery life, performance, and responsiveness of applications for the benefit of the user. This API can be used to 
			 give hints to the system that your application has special requirements. In response to creating one of these activities, the system will disable some 
			 or all of the heuristics so your application can finish quickly while still providing responsive behavior if the user needs it.
 
			 These activities can be used when your application is performing a long-running operation. If the activity can take different amounts of time (for 
			 example, calculating the next move in a chess game), it should use this API. This will ensure correct behavior when the amount of data or the 
			 capabilities of the user's computer varies. You should put your activity into one of two major categories:
 
			 User initiated: These are finite length activities that the user has explicitly started. Examples include exporting or downloading a user specified file.
 
			 Background: These are finite length activities that are part of the normal operation of your application but are not explicitly started by the user. 
			 
			 Examples include autosaving, indexing, and automatic downloading of files.
 
			 In addition, if your application requires high priority IO, you can include the 'NSActivityLatencyCritical' flag (using a bitwise or). This should be 
			 reserved for activities like audio or video recording.
 
			 If your activity takes place synchronously inside an event callback on the main thread, you do not need to use this API.
 
			 Be aware that failing to end these activities for an extended period of time can have significant negative impacts to the performance of your user's 
			 computer, so be sure to use only the minimum amount of time required. User preferences may override your applicationâ€™s request.
 
			 This API can also be used to control auto termination or sudden termination. 
 
			    id activity = [[NSProcessInfo processInfo] beginActivityWithOptions:NSActivityAutomaticTerminationDisabled reason:@"Good Reason"];
			    // work
			    [[NSProcessInfo processInfo] endActivity:activity];
 
			 is equivalent to:
 
			    [[NSProcessInfo processInfo] disableAutomaticTermination:@"Good Reason"];
			    // work
			    [[NSProcessInfo processInfo] enableAutomaticTermination:@"Good Reason"]
 
			 Since this API returns an object, it may be easier to pair begins and ends. If the object is deallocated before the -endActivity: call, the activity 
			 will be automatically ended.
 
			 This API also provides a mechanism to disable system-wide idle sleep and display idle sleep. These can have a large impact on the user experience, so be 
			 sure not to forget to end activities that disable sleep (including NSActivityUserInitiated).
 
			 */

			typedef NS_OPTIONS(uint64_t, NSActivityOptions) {
			    // To include one of these individual flags in one of the sets, use bitwise or:
			    //   NSActivityUserInitiated | NSActivityIdleDisplaySleepDisabled
			    // (this may be used during a presentation, for example)
    
			    // To exclude from one of the sets, use bitwise and with not:
			    //   NSActivityUserInitiated & ~NSActivitySuddenTerminationDisabled
			    // (this may be used during a user intiated action that may be safely terminated with no application interaction in case of logout)
    
			    // Used for activities that require the screen to stay powered on.
			    NSActivityIdleDisplaySleepDisabled = (1ULL << 40),
    
			    // Used for activities that require the computer to not idle sleep. This is included in NSActivityUserInitiated.
			    NSActivityIdleSystemSleepDisabled = (1ULL << 20),
    
			    // Prevents sudden termination. This is included in NSActivityUserInitiated.
			    NSActivitySuddenTerminationDisabled = (1ULL << 14),
    
			    // Prevents automatic termination. This is included in NSActivityUserInitiated.
			    NSActivityAutomaticTerminationDisabled = (1ULL << 15),
    
			    // ----
			    // Sets of options.
    
			    // App is performing a user-requested action.
			    NSActivityUserInitiated = (0x00FFFFFFULL | NSActivityIdleSystemSleepDisabled),
			    NSActivityUserInitiatedAllowingIdleSystemSleep = (NSActivityUserInitiated & ~NSActivityIdleSystemSleepDisabled),
    
			    // App has initiated some kind of work, but not as the direct result of user request.
			    NSActivityBackground = 0x000000FFULL,
    
			    // Used for activities that require the highest amount of timer and I/O precision available. Very few applications should need to use this constant.
			    NSActivityLatencyCritical = 0xFF00000000ULL,
			} NS_ENUM_AVAILABLE(10_9, 7_0);

			@interface NSProcessInfo ()
			/*
			 * Pass in an activity to this API, and a non-NULL, non-empty reason string. Indicate completion of the activity by calling the corresponding 
			 	endActivity: method with the result of the beginActivityWithOptions:reason: method. The reason string is used for debugging.
			 */
			- (id <NSObject>)beginActivityWithOptions:(NSActivityOptions)options reason:(NSString *)reason NS_AVAILABLE(10_9, 7_0);

			/*
			 * The argument to this method is the result of beginActivityWithOptions:reason:.
			 */
			- (void)endActivity:(id <NSObject>)activity NS_AVAILABLE(10_9, 7_0);

			/*
			 * Synchronously perform an activity. The activity will be automatically ended after your block argument returns. The reason string is used for debugging.
			 */
			- (void)performActivityWithOptions:(NSActivityOptions)options reason:(NSString *)reason usingBlock:(void (^)(void))block NS_AVAILABLE(10_9, 7_0);

			@end

			// Describes the current thermal state of the system.
			typedef NS_ENUM(NSInteger, NSProcessInfoThermalState) {
			    // No corrective action is needed.
			    NSProcessInfoThermalStateNominal,
    
			    // The system has reached a state where fans may become audible.
			    NSProcessInfoThermalStateFair,

			    // Fans are running at maximum speed, system performance maybe impacted. Recommendation: reduce application's usage of CPU, GPU and I/O, if possible. 
				
				Switch to lower quality visual effects, reduce frame rates.
			    NSProcessInfoThermalStateSerious,
    
			    // System performance is significantly impacted and the Mac needs to cool down. Recommendation: reduce application's usage of CPU, GPU, and I/O to 
					the minimum level needed to respond to user actions. Consider stopping use of camera and other peripherals if your application is using them.
			    NSProcessInfoThermalStateCritical
			} NS_ENUM_AVAILABLE(10_10_3, NA);

			@interface NSProcessInfo ()

			// Retrieve the current thermal state of the system. On systems where thermal state is unknown or unsupported, the value returned from the thermalState 
				property is always NSProcessInfoThermalStateNominal.

			@property (readonly) NSProcessInfoThermalState thermalState NS_AVAILABLE(10_10_3, NA);

			@end

			/*
			 This notification is posted once the thermal state of the system has changed. Once the notification is posted, use the thermalState property to retrieve 
			 the current thermal state of the system.
 
			 You can use this opportunity to take corrective action in your application to help cool the system down. Work that could be done in the background or at 
			 opportunistic times should be using the Quality of Service levels in NSOperation or the NSBackgroundActivityScheduler API.
 
			 This notification is posted on the global dispatch queue. Register for it using the default notification center. The object associated with the 
			 notification is +[NSProcessInfo processInfo].
			*/
			FOUNDATION_EXTERN NSString * const NSProcessInfoThermalStateDidChangeNotification NS_AVAILABLE(10_10_3, NA);

	
NSRegularExpression
			typedef NS_OPTIONS(NSUInteger, NSRegularExpressionOptions) {
			   NSRegularExpressionCaseInsensitive             = 1 << 0,     /* Match letters in the pattern independent of case. */
			   NSRegularExpressionAllowCommentsAndWhitespace  = 1 << 1,     /* Ignore whitespace and #-prefixed comments in the pattern. */
			   NSRegularExpressionIgnoreMetacharacters        = 1 << 2,     /* Treat the entire pattern as a literal string. */
			   NSRegularExpressionDotMatchesLineSeparators    = 1 << 3,     /* Allow . to match any character, including line separators. */
			   NSRegularExpressionAnchorsMatchLines           = 1 << 4,     /* Allow ^ and $ to match the start and end of lines. */
			   NSRegularExpressionUseUnixLineSeparators       = 1 << 5,     /* Treat only \n as a line separator (otherwise, all standard line separators are used). 
			   																*/
			   NSRegularExpressionUseUnicodeWordBoundaries    = 1 << 6      /* Use Unicode TR#29 to specify word boundaries (otherwise, traditional regular 
			   																	expression word boundaries are used). */
			};
			/* An instance of NSRegularExpression is created from a regular expression pattern and a set of options.  If the pattern is invalid, nil will be returned 
				and an NSError will be returned by reference.  The pattern syntax currently supported is that specified by ICU.
			*/
			+ (NSRegularExpression *)regularExpressionWithPattern:(NSString *)pattern options:(NSRegularExpressionOptions)options error:(NSError **)error;
			- (instancetype)initWithPattern:(NSString *)pattern options:(NSRegularExpressionOptions)options error:(NSError **)error NS_DESIGNATED_INITIALIZER;

			@property (readonly, copy) NSString *pattern;
			@property (readonly) NSRegularExpressionOptions options;
			@property (readonly) NSUInteger numberOfCaptureGroups;

			/* This class method will produce a string by adding backslash escapes as necessary to the given string, to escape any characters that would otherwise be 
				treated as pattern metacharacters.
			*/
			+ (NSString *)escapedPatternForString:(NSString *)string;

			/* The fundamental matching method on NSRegularExpression is a block iterator.  There are several additional convenience methods, for returning all 
			matches at once, the number of matches, the first match, or the range of the first match.  Each match is specified by an instance of NSTextCheckingResult 
			(of type NSTextCheckingTypeRegularExpression) in which the overall match range is given by the range property (equivalent to rangeAtIndex:0) and any 
			capture group ranges are given by rangeAtIndex: for indexes from 1 to numberOfCaptureGroups.  {NSNotFound, 0} is used if a particular capture group does 
			not participate in the match.
			*/

			- (void)enumerateMatchesInString:(NSString *)string options:(NSMatchingOptions)options range:(NSRange)range usingBlock:(void (^)(NSTextCheckingResult 
				*result, NSMatchingFlags flags, BOOL *stop))block;

			- (NSArray *)matchesInString:(NSString *)string options:(NSMatchingOptions)options range:(NSRange)range;
			- (NSUInteger)numberOfMatchesInString:(NSString *)string options:(NSMatchingOptions)options range:(NSRange)range;
			- (NSTextCheckingResult *)firstMatchInString:(NSString *)string options:(NSMatchingOptions)options range:(NSRange)range;
			- (NSRange)rangeOfFirstMatchInString:(NSString *)string options:(NSMatchingOptions)options range:(NSRange)range;

				/* By default, the block iterator method calls the block precisely once for each match, with a non-nil result and appropriate flags.  The client may 
				then stop the operation by setting the contents of stop to YES.  If the NSMatchingReportProgress option is specified, the block will also be called 
				periodically during long-running match operations, with nil result and NSMatchingProgress set in the flags, at which point the client may again stop 
				the operation by setting the contents of stop to YES.  If the NSMatchingReportCompletion option is specified, the block will be called once after 
				matching is complete, with nil result and NSMatchingCompleted set in the flags, plus any additional relevant flags from among NSMatchingHitEnd, 
				NSMatchingRequiredEnd, or NSMatchingInternalError.  NSMatchingReportProgress and NSMatchingReportCompletion have no effect for methods other than the 
				block iterator.
				

				NSMatchingHitEnd is set in the flags passed to the block if the current match operation reached the end of the search range.  NSMatchingRequiredEnd 
				is set in the flags passed to the block if the current match depended on the location of the end of the search range.  NSMatchingInternalError is set 
				in the flags passed to the block if matching failed due to an internal error (such as an expression requiring exponential memory allocations) without 
				examining the entire search range.

				NSMatchingAnchored, NSMatchingWithTransparentBounds, and NSMatchingWithoutAnchoringBounds can apply to any match or replace method.  If 
				NSMatchingAnchored is specified, matches are limited to those at the start of the search range.  If NSMatchingWithTransparentBounds is specified, 
				matching may examine parts of the string beyond the bounds of the search range, for purposes such as word boundary detection, lookahead, etc.  If 
				NSMatchingWithoutAnchoringBounds is specified, ^ and $ will not automatically match the beginning and end of the search range (but will still match 
				the beginning and end of the entire string).  NSMatchingWithTransparentBounds and NSMatchingWithoutAnchoringBounds have no effect if the search range 
				covers the entire string.

				NSRegularExpression is designed to be immutable and threadsafe, so that a single instance can be used in matching operations on multiple threads at 
				once.  However, the string on which it is operating should not be mutated during the course of a matching operation (whether from another thread or 
				from within the block used in the iteration).
				*/

				/* NSRegularExpression also provides find-and-replace methods for both immutable and mutable strings.  The replacement is treated as a template, with 
				$0 being replaced by the contents of the matched range, $1 by the contents of the first capture group, and so on.  Additional digits beyond the 
				maximum required to represent the number of capture groups will be treated as ordinary characters, as will a $ not followed by digits.  Backslash 
				will escape both $ and itself.
				*/
				
				- (NSString *)stringByReplacingMatchesInString:(NSString *)string options:(NSMatchingOptions)options range:(NSRange)range withTemplate:(NSString 
				*)templ;
				
				- (NSUInteger)replaceMatchesInString:(NSMutableString *)string options:(NSMatchingOptions)options range:(NSRange)range withTemplate:(NSString *)templ;

				/* For clients implementing their own replace functionality, this is a method to perform the template substitution for a single result, given the 
				string from which the result was matched, an offset to be added to the location of the result in the string (for example, in case modifications to 
				the string moved the result since it was matched), and a replacement template.
				*/
				
				- (NSString *)replacementStringForResult:(NSTextCheckingResult *)result inString:(NSString *)string offset:(NSInteger)offset template:(NSString 
				*)templ;

				/* This class method will produce a string by adding backslash escapes as necessary to the given string, to escape any characters that would 
				otherwise be treated as template metacharacters. 
				*/
				
				+ (NSString *)escapedTemplateForString:(NSString *)string;

NSDataDetector

			/* NSDataDetector is a specialized subclass of NSRegularExpression.  Instead of finding matches to regular expression patterns, it matches items 
				identified by Data Detectors, such as dates, addresses, and URLs.  The checkingTypes argument should contain one or more of the types 
				NSTextCheckingTypeDate, NSTextCheckingTypeAddress, NSTextCheckingTypeLink, NSTextCheckingTypePhoneNumber, and NSTextCheckingTypeTransitInformation.  				The NSTextCheckingResult instances returned will be of the appropriate types from that list.
			*/
			+ (NSDataDetector *)dataDetectorWithTypes:(NSTextCheckingTypes)checkingTypes error:(NSError **)error;
			- (instancetype)initWithTypes:(NSTextCheckingTypes)checkingTypes error:(NSError **)error NS_DESIGNATED_INITIALIZER;

			@property (readonly) NSTextCheckingTypes checkingTypes;


NSRunLoop

		FOUNDATION_EXPORT NSString * const NSDefaultRunLoopMode;
		FOUNDATION_EXPORT NSString * const NSRunLoopCommonModes NS_AVAILABLE(10_5, 2_0);

		+ (NSRunLoop *)currentRunLoop;
		+ (NSRunLoop *)mainRunLoop NS_AVAILABLE(10_5, 2_0);

		@property (readonly, copy) NSString *currentMode;

		- (void)addTimer:(NSTimer *)timer forMode:(NSString *)mode;
		- (void)run; 
		- (void)runUntilDate:(NSDate *)limitDate;
		- (BOOL)runMode:(NSString *)mode beforeDate:(NSDate *)limitDate;
		- (void)performSelector:(SEL)aSelector withObject:(id)anArgument afterDelay:(NSTimeInterval)delay inModes:(NSArray *)modes;
		- (void)performSelector:(SEL)aSelector withObject:(id)anArgument afterDelay:(NSTimeInterval)delay;
		+ (void)cancelPreviousPerformRequestsWithTarget:(id)aTarget selector:(SEL)aSelector object:(id)anArgument;
		+ (void)cancelPreviousPerformRequestsWithTarget:(id)aTarget;
		- (void)performSelector:(SEL)aSelector target:(id)target argument:(id)arg order:(NSUInteger)order modes:(NSArray *)modes;
		- (void)cancelPerformSelector:(SEL)aSelector target:(id)target argument:(id)arg;
		- (void)cancelPerformSelectorsWithTarget:(id)target;

NSConnection

NSPort

NSSocketPort
		- (instancetype)init;
		- (instancetype)initWithTCPPort:(unsigned short)port;
		- (instancetype)initWithProtocolFamily:(int)family socketType:(int)type protocol:(int)protocol address:(NSData *)address NS_DESIGNATED_INITIALIZER;
		- (instancetype)initWithProtocolFamily:(int)family socketType:(int)type protocol:(int)protocol socket:(NSSocketNativeHandle)sock NS_DESIGNATED_INITIALIZER;
		- (instancetype)initRemoteWithTCPPort:(unsigned short)port host:(NSString *)hostName;
		- (instancetype)initRemoteWithProtocolFamily:(int)family socketType:(int)type protocol:(int)protocol address:(NSData *)address NS_DESIGNATED_INITIALIZER;


		@property (readonly) int protocolFamily;
		@property (readonly) int socketType;
		@property (readonly) int protocol;
		@property (readonly, copy) NSData *address;
		@property (readonly) NSSocketNativeHandle socket;


NSScanner

		@property (readonly, copy) NSString *string;
		@property NSUInteger scanLocation;
		@property (copy) NSCharacterSet *charactersToBeSkipped;
		@property BOOL caseSensitive;

		- (instancetype)initWithString:(NSString *)string NS_DESIGNATED_INITIALIZER;

		- (BOOL)scanInt:(int *)result;
		- (BOOL)scanInteger:(NSInteger *)result NS_AVAILABLE(10_5, 2_0);
		- (BOOL)scanLongLong:(long long *)result;
		- (BOOL)scanUnsignedLongLong:(unsigned long long *)result NS_AVAILABLE(10_9, 7_0);
		- (BOOL)scanFloat:(float *)result;
		- (BOOL)scanDouble:(double *)result;
		- (BOOL)scanHexInt:(unsigned *)result;                                          // Optionally prefixed with "0x" or "0X"
		- (BOOL)scanHexLongLong:(unsigned long long *)result NS_AVAILABLE(10_5, 2_0);   // Optionally prefixed with "0x" or "0X"
		- (BOOL)scanHexFloat:(float *)result NS_AVAILABLE(10_5, 2_0);                   // Corresponding to %a or %A formatting. Requires "0x" or "0X" prefix.
		- (BOOL)scanHexDouble:(double *)result NS_AVAILABLE(10_5, 2_0);                 // Corresponding to %a or %A formatting. Requires "0x" or "0X" prefix.

		- (BOOL)scanString:(NSString *)string intoString:(NSString **)result;
		- (BOOL)scanCharactersFromSet:(NSCharacterSet *)set intoString:(NSString **)result;

		- (BOOL)scanUpToString:(NSString *)string intoString:(NSString **)result;
		- (BOOL)scanUpToCharactersFromSet:(NSCharacterSet *)set intoString:(NSString **)result;

		@property (getter=isAtEnd, readonly) BOOL atEnd;

		+ (instancetype)scannerWithString:(NSString *)string;

NSTimer
		+ (NSTimer *)timerWithTimeInterval:(NSTimeInterval)ti invocation:(NSInvocation *)invocation repeats:(BOOL)yesOrNo;
		+ (NSTimer *)scheduledTimerWithTimeInterval:(NSTimeInterval)ti invocation:(NSInvocation *)invocation repeats:(BOOL)yesOrNo;

		+ (NSTimer *)timerWithTimeInterval:(NSTimeInterval)ti target:(id)aTarget selector:(SEL)aSelector userInfo:(id)userInfo repeats:(BOOL)yesOrNo;
		+ (NSTimer *)scheduledTimerWithTimeInterval:(NSTimeInterval)ti target:(id)aTarget selector:(SEL)aSelector userInfo:(id)userInfo repeats:(BOOL)yesOrNo;

		- (instancetype)initWithFireDate:(NSDate *)date interval:(NSTimeInterval)ti target:(id)t selector:(SEL)s userInfo:(id)ui repeats:(BOOL)rep 		NS_DESIGNATED_INITIALIZER;

		- (void)fire;
		@property NSTimeInterval tolerance NS_AVAILABLE(10_9, 7_0);

		- (void)invalidate;
		@property (readonly, getter=isValid) BOOL valid;

		@property (readonly, retain) id userInfo;

		@property (copy) NSDate *fireDate;
		@property (readonly) NSTimeInterval timeInterval;


NSXMLParser


NSSortDescriptor

NSSet

NSTextCheckingTypes


NSDecimalNumber

NSDecimal

NSNumberFormatter
				